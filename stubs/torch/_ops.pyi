# pylint: disable=multiple-statements,unused-argument, invalid-name
# pylint: disable=too-few-public-methods,useless-import-alias, unused-import
# pylint: disable=redefined-builtin,super-init-not-called, arguments-renamed
# pylint: disable=abstract-method,too-many-ancestors, import-error
# pylint: disable=relative-beyond-top-level,redefined-outer-name
# pylint: disable=arguments-differ,no-member, keyword-arg-before-vararg
# pylint: disable=signature-differs,blacklisted-name, c-extension-no-member
# pylint: disable=protected-access,no-name-in-module, undefined-variable


import types
from collections.abc import Generator

from _typeshed import Incomplete


def dl_open_guard() -> Generator[None, None, None]: ...


class OpOverload:
    __name__: Incomplete
    __module__: Incomplete
    def __init__(self, overloadpacket, op, schema) -> None: ...
    def __deepcopy__(self, memo: Incomplete | None = ...): ...
    def __call__(self, *args, **kwargs): ...
    def __getattr__(self, key): ...
    def __hash__(self): ...
    @property
    def overloadpacket(self): ...
    @property
    def op(self): ...


class OpOverloadPacket:
    __name__: Incomplete

    def __init__(
        self, qualified_op_name, op_name, op, overload_names) -> None: ...

    def __deepcopy__(self, memo: Incomplete | None = ...): ...
    def __hash__(self): ...
    @property
    def op(self): ...
    def __getattr__(self, key): ...
    def __call__(self, *args, **kwargs): ...
    def overloads(self): ...


class _OpNamespace(types.ModuleType):
    name: Incomplete
    def __init__(self, name) -> None: ...
    def __getattr__(self, op_name): ...


class _Ops(types.ModuleType):
    __file__: str
    loaded_libraries: Incomplete
    def __init__(self) -> None: ...
    def __getattr__(self, name): ...
    def load_library(self, path) -> None: ...


ops: Incomplete
